Index: include/trajectory_follower_nodes/longitudinal_controller_node.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright 2021 Tier IV, Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef TRAJECTORY_FOLLOWER_NODES__LONGITUDINAL_CONTROLLER_NODE_HPP_\n#define TRAJECTORY_FOLLOWER_NODES__LONGITUDINAL_CONTROLLER_NODE_HPP_\n\n#include \"eigen3/Eigen/Core\"\n#include \"eigen3/Eigen/Geometry\"\n#include \"motion_common/motion_common.hpp\"\n#include \"motion_common/trajectory_common.hpp\"\n#include \"rclcpp/rclcpp.hpp\"\n#include \"tf2/utils.h\"\n#include \"tf2_ros/buffer.h\"\n#include \"tf2_ros/transform_listener.h\"\n#include \"trajectory_follower/debug_values.hpp\"\n#include \"trajectory_follower/longitudinal_controller_utils.hpp\"\n#include \"trajectory_follower/lowpass_filter.hpp\"\n#include \"trajectory_follower/pid.hpp\"\n#include \"trajectory_follower/smooth_stop.hpp\"\n#include \"vehicle_info_util/vehicle_info_util.hpp\"\n\n#include \"autoware_auto_control_msgs/msg/longitudinal_command.hpp\"\n#include \"autoware_auto_planning_msgs/msg/trajectory.hpp\"\n#include \"autoware_auto_system_msgs/msg/float32_multi_array_diagnostic.hpp\"\n#include \"autoware_auto_vehicle_msgs/msg/controller_error_report.hpp\"\n#include \"autoware_auto_vehicle_msgs/msg/delay_compensation_refs.hpp\"\n#include \"autoware_auto_vehicle_msgs/msg/vehicle_odometry.hpp\"\n#include \"geometry_msgs/msg/pose_stamped.hpp\"\n#include \"nav_msgs/msg/odometry.hpp\"\n#include \"tf2_msgs/msg/tf_message.hpp\"\n\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace autoware\n{\nnamespace motion\n{\nnamespace control\n{\nnamespace trajectory_follower_nodes\n{\nusing autoware::common::types::bool8_t;\nusing autoware::common::types::float64_t;\nnamespace trajectory_follower = ::autoware::motion::control::trajectory_follower;\nnamespace motion_common = ::autoware::motion::motion_common;\nusing autoware_auto_vehicle_msgs::msg::ControllerErrorReport;\nusing autoware_auto_vehicle_msgs::msg::DelayCompensationRefs;\nusing namespace std::literals::chrono_literals;\n\n/// \\class LongitudinalController\n/// \\brief The node class used for generating longitudinal control commands (velocity/acceleration)\nclass TRAJECTORY_FOLLOWER_PUBLIC LongitudinalController : public rclcpp::Node\n{\npublic:\n  explicit LongitudinalController(const rclcpp::NodeOptions & node_options);\n\nprivate:\n  struct Motion\n  {\n    float64_t vel{0.0};\n    float64_t acc{0.0};\n  };\n\n  enum class Shift { Forward = 0, Reverse };\n\n  struct ControlData\n  {\n    bool8_t is_far_from_trajectory{false};\n    size_t nearest_idx{0};  // nearest_idx = 0 when nearest_idx is not found with findNearestIdx\n    Motion current_motion{};\n    Shift shift{Shift::Forward};  // shift is used only to calculate the sign of pitch compensation\n    float64_t stop_dist{0.0};  // signed distance that is positive when car is before the stopline\n    float64_t slope_angle{0.0};\n    float64_t dt{0.0};\n  };\n\n  // ros variables\n  rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr m_sub_current_velocity;\n  rclcpp::Subscription<autoware_auto_planning_msgs::msg::Trajectory>::SharedPtr m_sub_trajectory;\n  rclcpp::Publisher<autoware_auto_control_msgs::msg::LongitudinalCommand>::SharedPtr\n    m_pub_control_cmd;\n  rclcpp::Publisher<autoware_auto_system_msgs::msg::Float32MultiArrayDiagnostic>::SharedPtr\n    m_pub_slope;\n  rclcpp::Publisher<autoware_auto_system_msgs::msg::Float32MultiArrayDiagnostic>::SharedPtr\n    m_pub_debug;\n  rclcpp::Publisher<ControllerErrorReport>::SharedPtr m_pub_ctrl_error_report;\n  rclcpp::TimerBase::SharedPtr m_timer_control;\n\n  rclcpp::Subscription<tf2_msgs::msg::TFMessage>::SharedPtr m_tf_sub;\n  rclcpp::Subscription<tf2_msgs::msg::TFMessage>::SharedPtr m_tf_static_sub;\n  tf2::BufferCore m_tf_buffer{tf2::BUFFER_CORE_DEFAULT_CACHE_TIME};\n  tf2_ros::TransformListener m_tf_listener{m_tf_buffer};\n\n  //!< @brief subscription for current communication delay compensator messages.\n  rclcpp::Subscription<DelayCompensationRefs>::SharedPtr m_sub_com_delay_;\n\n  OnSetParametersCallbackHandle::SharedPtr m_set_param_res;\n  rcl_interfaces::msg::SetParametersResult paramCallback(\n    const std::vector<rclcpp::Parameter> & parameters);\n\n  // pointers for ros topic\n  std::shared_ptr<nav_msgs::msg::Odometry> m_current_velocity_ptr{nullptr};\n  std::shared_ptr<nav_msgs::msg::Odometry> m_prev_velocity_ptr{nullptr};\n  std::shared_ptr<autoware_auto_planning_msgs::msg::Trajectory> m_trajectory_ptr{nullptr};\n\n  //!< @brief current communication delay message pointer.\n  DelayCompensationRefs::SharedPtr m_current_comm_delay_ptr{nullptr};\n\n  // vehicle info\n  float64_t m_wheel_base;\n\n  // control state\n  enum class ControlState { DRIVE = 0, STOPPING, STOPPED, EMERGENCY };\n  ControlState m_control_state{ControlState::STOPPED};\n\n  // control period\n  float64_t m_longitudinal_ctrl_period;\n\n  // delay compensation\n  float64_t m_delay_compensation_time;\n\n  // enable flags\n  bool8_t m_enable_smooth_stop;\n  bool8_t m_enable_overshoot_emergency;\n  bool8_t m_enable_slope_compensation;\n\n  // smooth stop transition\n  struct StateTransitionParams\n  {\n    // drive\n    float64_t drive_state_stop_dist;\n    float64_t drive_state_offset_stop_dist;\n    // stopping\n    float64_t stopping_state_stop_dist;\n    // stop\n    float64_t stopped_state_entry_duration_time;\n    float64_t stopped_state_entry_vel;\n    float64_t stopped_state_entry_acc;\n    // emergency\n    float64_t emergency_state_overshoot_stop_dist;\n    float64_t emergency_state_traj_trans_dev;\n    float64_t emergency_state_traj_rot_dev;\n  };\n  StateTransitionParams m_state_transition_params;\n\n  // drive\n  trajectory_follower::PIDController m_pid_vel;\n  std::shared_ptr<trajectory_follower::LowpassFilter1d> m_lpf_vel_error{nullptr};\n  float64_t m_current_vel_threshold_pid_integrate;\n  bool8_t m_enable_brake_keeping_before_stop;\n  float64_t m_brake_keeping_acc;\n\n  // Error reports for the communication delay observers\n  float64_t m_current_velocity_error_to_report{};\n  float64_t m_current_acc_error_to_report{};\n\n  // smooth stop\n  trajectory_follower::SmoothStop m_smooth_stop;\n\n  // stop\n  struct StoppedStateParams\n  {\n    float64_t vel;\n    float64_t acc;\n    float64_t jerk;\n  };\n  StoppedStateParams m_stopped_state_params;\n\n  // emergency\n  struct EmergencyStateParams\n  {\n    float64_t vel;\n    float64_t acc;\n    float64_t jerk;\n  };\n  EmergencyStateParams m_emergency_state_params;\n\n  // acceleration limit\n  float64_t m_max_acc;\n  float64_t m_min_acc;\n\n  // jerk limit\n  float64_t m_max_jerk;\n  float64_t m_min_jerk;\n\n  // slope compensation\n  bool8_t m_use_traj_for_pitch;\n  std::shared_ptr<trajectory_follower::LowpassFilter1d> m_lpf_pitch{nullptr};\n  float64_t m_max_pitch_rad;\n  float64_t m_min_pitch_rad;\n\n  // 1st order lowpass filter for acceleration\n  std::shared_ptr<trajectory_follower::LowpassFilter1d> m_lpf_acc{nullptr};\n\n  // buffer of send command\n  std::vector<autoware_auto_control_msgs::msg::LongitudinalCommand> m_ctrl_cmd_vec;\n\n  // for calculating dt\n  std::shared_ptr<rclcpp::Time> m_prev_control_time{nullptr};\n\n  // shift mode\n  Shift m_prev_shift{Shift::Forward};\n\n  // diff limit\n  Motion m_prev_ctrl_cmd{};      // with slope compensation\n  Motion m_prev_raw_ctrl_cmd{};  // without slope compensation\n  std::vector<std::pair<rclcpp::Time, float64_t>> m_vel_hist;\n\n  // debug values\n  trajectory_follower::DebugValues m_debug_values;\n\n  std::shared_ptr<rclcpp::Time> m_last_running_time{std::make_shared<rclcpp::Time>(this->now())};\n\n  /**\n   * @brief set current and previous velocity with received message\n   * @param [in] msg current state message\n   */\n  void callbackCurrentVelocity(const nav_msgs::msg::Odometry::ConstSharedPtr msg);\n\n  /**\n   * @brief set reference trajectory with received message\n   * @param [in] msg trajectory message\n   */\n  void callbackTrajectory(const autoware_auto_planning_msgs::msg::Trajectory::ConstSharedPtr msg);\n\n  /**\n   * @brief compute control command, and publish periodically\n   */\n  void callbackTimerControl();\n\n  /**\n   * @brief received communication time delay compensation message.\n   */\n  void onCommDelayCompensation(const DelayCompensationRefs::SharedPtr msg);\n\n  /**\n   * @brief calculate data for controllers whose type is ControlData\n   * @param [in] current_pose current ego pose\n   */\n  ControlData getControlData(const geometry_msgs::msg::Pose & current_pose);\n\n  /**\n   * @brief calculate control command in emergency state\n   * @param [in] dt time between previous and current one\n   */\n  Motion calcEmergencyCtrlCmd(const float64_t dt) const;\n\n  /**\n   * @brief update control state according to the current situation\n   * @param [in] current_control_state current control state\n   * @param [in] control_data control data\n   */\n  ControlState updateControlState(\n    const ControlState current_control_state, const ControlData & control_data);\n\n  /**\n   * @brief calculate control command based on the current control state\n   * @param [in] current_control_state current control state\n   * @param [in] current_pose current ego pose\n   * @param [in] control_data control data\n   */\n  Motion calcCtrlCmd(\n    const ControlState & current_control_state, const geometry_msgs::msg::Pose & current_pose,\n    const ControlData & control_data);\n\n  /**\n   * @brief publish control command\n   * @param [in] ctrl_cmd calculated control command to control velocity\n   * @param [in] current_vel current velocity of the vehicle\n   */\n  void publishCtrlCmd(const Motion & ctrl_cmd, const float64_t current_vel);\n\n  /**\n   * @brief publish debug data\n   * @param [in] ctrl_cmd calculated control command to control velocity\n   * @param [in] control_data data for control calculation\n   */\n  void publishDebugData(const Motion & ctrl_cmd, const ControlData & control_data);\n\n  /**\n   * @brief calculate time between current and previous one\n   */\n  float64_t getDt();\n\n  /**\n   * @brief calculate current velocity and acceleration\n   */\n  Motion getCurrentMotion() const;\n\n  /**\n   * @brief calculate direction (forward or backward) that vehicle moves\n   * @param [in] nearest_idx nearest index on trajectory to vehicle\n   */\n  enum Shift getCurrentShift(const size_t nearest_idx) const;\n\n  /**\n   * @brief filter acceleration command with limitation of acceleration and jerk, and slope\n   * compensation\n   * @param [in] raw_acc acceleration before filtered\n   * @param [in] control_data data for control calculation\n   */\n  float64_t calcFilteredAcc(const float64_t raw_acc, const ControlData & control_data);\n\n  /**\n   * @brief store acceleration command before slope compensation\n   * @param [in] accel command before slope compensation\n   */\n  void storeAccelCmd(const float64_t accel);\n\n  /**\n   * @brief add acceleration to compensate for slope\n   * @param [in] acc acceleration before slope compensation\n   * @param [in] pitch pitch angle (upward is negative)\n   * @param [in] shift direction that vehicle move (forward or backward)\n   */\n  float64_t applySlopeCompensation(\n    const float64_t acc, const float64_t pitch, const Shift shift) const;\n\n  /**\n   * @brief keep target motion acceleration negative before stop\n   * @param [in] traj reference trajectory\n   * @param [in] motion delay compensated target motion\n   */\n  Motion keepBrakeBeforeStop(\n    const autoware_auto_planning_msgs::msg::Trajectory & traj, const Motion & target_motion,\n    const size_t nearest_idx) const;\n\n  /**\n   * @brief interpolate trajectory point that is nearest to vehicle\n   * @param [in] traj reference trajectory\n   * @param [in] point vehicle position\n   * @param [in] nearest_idx index of the trajectory point nearest to the vehicle position\n   */\n  autoware_auto_planning_msgs::msg::TrajectoryPoint calcInterpolatedTargetValue(\n    const autoware_auto_planning_msgs::msg::Trajectory & traj,\n    const geometry_msgs::msg::Point & point, const size_t nearest_idx) const;\n\n  /**\n   * @brief calculate predicted velocity after time delay based on past control commands\n   * @param [in] current_motion current velocity and acceleration of the vehicle\n   * @param [in] delay_compensation_time predicted time delay\n   */\n  float64_t predictedVelocityInTargetPoint(\n    const Motion current_motion, const float64_t delay_compensation_time) const;\n\n  /**\n   * @brief calculate velocity feedback with feed forward and pid controller\n   * @param [in] target_motion reference velocity and acceleration. This acceleration will be used\n   * as feed forward.\n   * @param [in] dt time step to use\n   * @param [in] current_vel current velocity of the vehicle\n   */\n  float64_t applyVelocityFeedback(\n    const Motion target_motion, const float64_t dt, const float64_t current_vel);\n\n  /**\n   * @brief update variables for debugging about pitch\n   * @param [in] pitch current pitch of the vehicle (filtered)\n   * @param [in] traj_pitch current trajectory pitch\n   * @param [in] raw_pitch current raw pitch of the vehicle (unfiltered)\n   */\n  void updatePitchDebugValues(\n    const float64_t pitch, const float64_t traj_pitch, const float64_t raw_pitch);\n\n  /**\n   * @brief update variables for velocity and acceleration\n   * @param [in] ctrl_cmd latest calculated control command\n   * @param [in] current_pose current pose of the vehicle\n   * @param [in] control_data data for control calculation\n   */\n  void updateDebugVelAcc(\n    const Motion & ctrl_cmd, const geometry_msgs::msg::Pose & current_pose,\n    const ControlData & control_data);\n\n  /**\n   * @brief calculates velocity and acceleration errors.\n   * */\n  void calcErrorReports(ControlData const & current_data, Motion const & target_motion);\n  /**\n   * @brief publish control errors\n   * @param [in] cmd published errors (velocity)\n   */\n  void publishErrors();\n};\n}  // namespace trajectory_follower_nodes\n}  // namespace control\n}  // namespace motion\n}  // namespace autoware\n\n#endif  // TRAJECTORY_FOLLOWER_NODES__LONGITUDINAL_CONTROLLER_NODE_HPP_\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/trajectory_follower_nodes/longitudinal_controller_node.hpp b/include/trajectory_follower_nodes/longitudinal_controller_node.hpp
--- a/include/trajectory_follower_nodes/longitudinal_controller_node.hpp	(revision c5c7724510fa7da49e3cf2fb9ba8357f407a21fe)
+++ b/include/trajectory_follower_nodes/longitudinal_controller_node.hpp	(date 1656122319108)
@@ -166,6 +166,7 @@
 
   // Error reports for the communication delay observers
   float64_t m_current_velocity_error_to_report{};
+  float64_t m_target_velocity_to_report{};
   float64_t m_current_acc_error_to_report{};
 
   // smooth stop
Index: src/longitudinal_controller_node.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright 2021 Tier IV, Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"trajectory_follower_nodes/longitudinal_controller_node.hpp\"\n\n#include \"motion_common/motion_common.hpp\"\n#include \"motion_common/trajectory_common.hpp\"\n#include \"time_utils/time_utils.hpp\"\n\n#include <algorithm>\n#include <limits>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace autoware\n{\nnamespace motion\n{\nnamespace control\n{\nnamespace trajectory_follower_nodes\n{\nLongitudinalController::LongitudinalController(const rclcpp::NodeOptions & node_options)\n: Node(\"longitudinal_controller\", node_options)\n{\n  using std::placeholders::_1;\n\n  // parameters timer\n  m_longitudinal_ctrl_period = declare_parameter<float64_t>(\"longitudinal_ctrl_period\");\n\n  m_wheel_base = vehicle_info_util::VehicleInfoUtil(*this).getVehicleInfo().wheel_base_m;\n\n  // parameters for delay compensation\n  m_delay_compensation_time = declare_parameter<float64_t>(\"delay_compensation_time\");  // [s]\n\n  // parameters to enable functions\n  m_enable_smooth_stop = declare_parameter<bool8_t>(\"enable_smooth_stop\");\n  m_enable_overshoot_emergency = declare_parameter<bool8_t>(\"enable_overshoot_emergency\");\n  m_enable_slope_compensation = declare_parameter<bool8_t>(\"enable_slope_compensation\");\n\n  // parameters for state transition\n  {\n    auto & p = m_state_transition_params;\n    // drive\n    p.drive_state_stop_dist = declare_parameter<float64_t>(\"drive_state_stop_dist\");  // [m]\n    p.drive_state_offset_stop_dist =\n      declare_parameter<float64_t>(\"drive_state_offset_stop_dist\");  // [m]\n    // stopping\n    p.stopping_state_stop_dist = declare_parameter<float64_t>(\"stopping_state_stop_dist\");  // [m]\n    p.stopped_state_entry_duration_time =\n      declare_parameter<float64_t>(\"stopped_state_entry_duration_time\");  // [s]\n    // stop\n    p.stopped_state_entry_vel = declare_parameter<float64_t>(\"stopped_state_entry_vel\");  // [m/s]\n    p.stopped_state_entry_acc = declare_parameter<float64_t>(\"stopped_state_entry_acc\");  // [m/s²]\n    // emergency\n    p.emergency_state_overshoot_stop_dist =\n      declare_parameter<float64_t>(\"emergency_state_overshoot_stop_dist\");  // [m]\n    p.emergency_state_traj_trans_dev =\n      declare_parameter<float64_t>(\"emergency_state_traj_trans_dev\");  // [m]\n    p.emergency_state_traj_rot_dev =\n      declare_parameter<float64_t>(\"emergency_state_traj_rot_dev\");  // [m]\n  }\n\n  // parameters for drive state\n  {\n    // initialize PID gain\n    const float64_t kp{declare_parameter<float64_t>(\"kp\")};\n    const float64_t ki{declare_parameter<float64_t>(\"ki\")};\n    const float64_t kd{declare_parameter<float64_t>(\"kd\")};\n    m_pid_vel.setGains(kp, ki, kd);\n\n    // initialize PID limits\n    const float64_t max_pid{declare_parameter<float64_t>(\"max_out\")};     // [m/s^2]\n    const float64_t min_pid{declare_parameter<float64_t>(\"min_out\")};     // [m/s^2]\n    const float64_t max_p{declare_parameter<float64_t>(\"max_p_effort\")};  // [m/s^2]\n    const float64_t min_p{declare_parameter<float64_t>(\"min_p_effort\")};  // [m/s^2]\n    const float64_t max_i{declare_parameter<float64_t>(\"max_i_effort\")};  // [m/s^2]\n    const float64_t min_i{declare_parameter<float64_t>(\"min_i_effort\")};  // [m/s^2]\n    const float64_t max_d{declare_parameter<float64_t>(\"max_d_effort\")};  // [m/s^2]\n    const float64_t min_d{declare_parameter<float64_t>(\"min_d_effort\")};  // [m/s^2]\n    m_pid_vel.setLimits(max_pid, min_pid, max_p, min_p, max_i, min_i, max_d, min_d);\n\n    // set lowpass filter for vel error and pitch\n    const float64_t lpf_vel_error_gain{declare_parameter<float64_t>(\"lpf_vel_error_gain\")};\n    m_lpf_vel_error =\n      std::make_shared<trajectory_follower::LowpassFilter1d>(0.0, lpf_vel_error_gain);\n\n    m_current_vel_threshold_pid_integrate =\n      declare_parameter<float64_t>(\"current_vel_threshold_pid_integration\");  // [m/s]\n\n    m_enable_brake_keeping_before_stop =\n      declare_parameter<bool8_t>(\"enable_brake_keeping_before_stop\");         // [-]\n    m_brake_keeping_acc = declare_parameter<float64_t>(\"brake_keeping_acc\");  // [m/s^2]\n  }\n\n  // parameters for smooth stop state\n  {\n    const float64_t max_strong_acc{\n      declare_parameter<float64_t>(\"smooth_stop_max_strong_acc\")};  // [m/s^2]\n    const float64_t min_strong_acc{\n      declare_parameter<float64_t>(\"smooth_stop_min_strong_acc\")};                   // [m/s^2]\n    const float64_t weak_acc{declare_parameter<float64_t>(\"smooth_stop_weak_acc\")};  // [m/s^2]\n    const float64_t weak_stop_acc{\n      declare_parameter<float64_t>(\"smooth_stop_weak_stop_acc\")};  // [m/s^2]\n    const float64_t strong_stop_acc{\n      declare_parameter<float64_t>(\"smooth_stop_strong_stop_acc\")};  // [m/s^2]\n\n    const float64_t max_fast_vel{\n      declare_parameter<float64_t>(\"smooth_stop_max_fast_vel\")};  // [m/s]\n    const float64_t min_running_vel{\n      declare_parameter<float64_t>(\"smooth_stop_min_running_vel\")};  // [m/s]\n    const float64_t min_running_acc{\n      declare_parameter<float64_t>(\"smooth_stop_min_running_acc\")};  // [m/s^2]\n    const float64_t weak_stop_time{\n      declare_parameter<float64_t>(\"smooth_stop_weak_stop_time\")};  // [s]\n\n    const float64_t weak_stop_dist{\n      declare_parameter<float64_t>(\"smooth_stop_weak_stop_dist\")};  // [m]\n    const float64_t strong_stop_dist{\n      declare_parameter<float64_t>(\"smooth_stop_strong_stop_dist\")};  // [m]\n\n    m_smooth_stop.setParams(\n      max_strong_acc, min_strong_acc, weak_acc, weak_stop_acc, strong_stop_acc, max_fast_vel,\n      min_running_vel, min_running_acc, weak_stop_time, weak_stop_dist, strong_stop_dist);\n  }\n\n  // parameters for stop state\n  {\n    auto & p = m_stopped_state_params;\n    p.vel = declare_parameter<float64_t>(\"stopped_vel\");    // [m/s]\n    p.acc = declare_parameter<float64_t>(\"stopped_acc\");    // [m/s^2]\n    p.jerk = declare_parameter<float64_t>(\"stopped_jerk\");  // [m/s^3]\n  }\n\n  // parameters for emergency state\n  {\n    auto & p = m_emergency_state_params;\n    p.vel = declare_parameter<float64_t>(\"emergency_vel\");    // [m/s]\n    p.acc = declare_parameter<float64_t>(\"emergency_acc\");    // [m/s^2]\n    p.jerk = declare_parameter<float64_t>(\"emergency_jerk\");  // [m/s^3]\n  }\n\n  // parameters for acceleration limit\n  m_max_acc = declare_parameter<float64_t>(\"max_acc\");  // [m/s^2]\n  m_min_acc = declare_parameter<float64_t>(\"min_acc\");  // [m/s^2]\n\n  // parameters for jerk limit\n  m_max_jerk = declare_parameter<float64_t>(\"max_jerk\");  // [m/s^3]\n  m_min_jerk = declare_parameter<float64_t>(\"min_jerk\");  // [m/s^3]\n\n  // parameters for slope compensation\n  m_use_traj_for_pitch = declare_parameter<bool8_t>(\"use_trajectory_for_pitch_calculation\");\n  const float64_t lpf_pitch_gain{declare_parameter<float64_t>(\"lpf_pitch_gain\")};\n  m_lpf_pitch = std::make_shared<trajectory_follower::LowpassFilter1d>(0.0, lpf_pitch_gain);\n  m_max_pitch_rad = declare_parameter<float64_t>(\"max_pitch_rad\");  // [rad]\n  m_min_pitch_rad = declare_parameter<float64_t>(\"min_pitch_rad\");  // [rad]\n\n  // subscriber, publisher\n  m_sub_current_velocity = create_subscription<nav_msgs::msg::Odometry>(\n    \"~/input/current_odometry\", rclcpp::QoS{1},\n    std::bind(&LongitudinalController::callbackCurrentVelocity, this, _1));\n  m_sub_trajectory = create_subscription<autoware_auto_planning_msgs::msg::Trajectory>(\n    \"~/input/current_trajectory\", rclcpp::QoS{1},\n    std::bind(&LongitudinalController::callbackTrajectory, this, _1));\n\n  m_sub_com_delay_ = create_subscription<DelayCompensationRefs>(\n    \"~/input/current_com_delay\", rclcpp::QoS{1},\n    std::bind(&LongitudinalController::onCommDelayCompensation, this, _1));\n\n  m_pub_control_cmd = create_publisher<autoware_auto_control_msgs::msg::LongitudinalCommand>(\n    \"~/output/control_cmd\", rclcpp::QoS{1});\n  m_pub_slope = create_publisher<autoware_auto_system_msgs::msg::Float32MultiArrayDiagnostic>(\n    \"~/output/slope_angle\", rclcpp::QoS{1});\n  m_pub_debug = create_publisher<autoware_auto_system_msgs::msg::Float32MultiArrayDiagnostic>(\n    \"~/output/diagnostic\", rclcpp::QoS{1});\n\n  m_pub_ctrl_error_report =\n    create_publisher<ControllerErrorReport>(\"~/output/longitudinal_controller_error_report\", 1);\n\n  // Timer\n  {\n    const auto period_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(\n      std::chrono::duration<float64_t>(m_longitudinal_ctrl_period));\n    m_timer_control = rclcpp::create_timer(\n      this, get_clock(), period_ns, std::bind(&LongitudinalController::callbackTimerControl, this));\n  }\n\n  // set parameter callback\n  m_set_param_res = this->add_on_set_parameters_callback(\n    std::bind(&LongitudinalController::paramCallback, this, _1));\n\n  // set lowpass filter for acc\n  m_lpf_acc = std::make_shared<trajectory_follower::LowpassFilter1d>(0.0, 0.2);\n}\n\nvoid LongitudinalController::callbackCurrentVelocity(\n  const nav_msgs::msg::Odometry::ConstSharedPtr msg)\n{\n  if (m_current_velocity_ptr) {\n    m_prev_velocity_ptr = m_current_velocity_ptr;\n  }\n  m_current_velocity_ptr = std::make_shared<nav_msgs::msg::Odometry>(*msg);\n}\n\nvoid LongitudinalController::onCommDelayCompensation(const DelayCompensationRefs::SharedPtr msg)\n{\n  m_current_comm_delay_ptr = msg;\n\n  if (m_current_comm_delay_ptr) {\n    RCLCPP_INFO_THROTTLE(\n      get_logger(), *get_clock(), (1000ms).count(), \"In longitudinal control, refs read  %4.2f \",\n      msg->velocity_error_compensation_ref);\n  }\n}\n\nvoid LongitudinalController::callbackTrajectory(\n  const autoware_auto_planning_msgs::msg::Trajectory::ConstSharedPtr msg)\n{\n  if (!trajectory_follower::longitudinal_utils::isValidTrajectory(*msg)) {\n    RCLCPP_ERROR_THROTTLE(get_logger(), *get_clock(), 3000, \"received invalid trajectory. ignore.\");\n    return;\n  }\n\n  if (msg->points.size() < 2) {\n    RCLCPP_WARN_THROTTLE(\n      get_logger(), *get_clock(), 3000, \"Unexpected trajectory size < 2. Ignored.\");\n    return;\n  }\n\n  m_trajectory_ptr = std::make_shared<autoware_auto_planning_msgs::msg::Trajectory>(*msg);\n}\n\nrcl_interfaces::msg::SetParametersResult LongitudinalController::paramCallback(\n  const std::vector<rclcpp::Parameter> & parameters)\n{\n  auto update_param = [&](const std::string & name, float64_t & v) {\n    auto it = std::find_if(\n      parameters.cbegin(), parameters.cend(),\n      [&name](const rclcpp::Parameter & parameter) { return parameter.get_name() == name; });\n    if (it != parameters.cend()) {\n      v = it->as_double();\n      return true;\n    }\n    return false;\n  };\n\n  // delay compensation\n  update_param(\"delay_compensation_time\", m_delay_compensation_time);\n\n  // state transition\n  {\n    auto & p = m_state_transition_params;\n    update_param(\"drive_state_stop_dist\", p.drive_state_stop_dist);\n    update_param(\"stopping_state_stop_dist\", p.stopping_state_stop_dist);\n    update_param(\"stopped_state_entry_duration_time\", p.stopped_state_entry_duration_time);\n    update_param(\"stopped_state_entry_vel\", p.stopped_state_entry_vel);\n    update_param(\"stopped_state_entry_acc\", p.stopped_state_entry_acc);\n    update_param(\"emergency_state_overshoot_stop_dist\", p.emergency_state_overshoot_stop_dist);\n    update_param(\"emergency_state_traj_trans_dev\", p.emergency_state_traj_trans_dev);\n    update_param(\"emergency_state_traj_rot_dev\", p.emergency_state_traj_rot_dev);\n  }\n\n  // drive state\n  {\n    float64_t kp{get_parameter(\"kp\").as_double()};\n    float64_t ki{get_parameter(\"ki\").as_double()};\n    float64_t kd{get_parameter(\"kd\").as_double()};\n    update_param(\"kp\", kp);\n    update_param(\"ki\", ki);\n    update_param(\"kd\", kd);\n    m_pid_vel.setGains(kp, ki, kd);\n\n    float64_t max_pid{get_parameter(\"max_out\").as_double()};\n    float64_t min_pid{get_parameter(\"min_out\").as_double()};\n    float64_t max_p{get_parameter(\"max_p_effort\").as_double()};\n    float64_t min_p{get_parameter(\"min_p_effort\").as_double()};\n    float64_t max_i{get_parameter(\"max_i_effort\").as_double()};\n    float64_t min_i{get_parameter(\"min_i_effort\").as_double()};\n    float64_t max_d{get_parameter(\"max_d_effort\").as_double()};\n    float64_t min_d{get_parameter(\"min_d_effort\").as_double()};\n    update_param(\"max_out\", max_pid);\n    update_param(\"min_out\", min_pid);\n    update_param(\"max_p_effort\", max_p);\n    update_param(\"min_p_effort\", min_p);\n    update_param(\"max_i_effort\", max_i);\n    update_param(\"min_i_effort\", min_i);\n    update_param(\"max_d_effort\", max_d);\n    update_param(\"min_d_effort\", min_d);\n    m_pid_vel.setLimits(max_pid, min_pid, max_p, min_p, max_i, min_i, max_d, min_d);\n\n    update_param(\"current_vel_threshold_pid_integration\", m_current_vel_threshold_pid_integrate);\n  }\n\n  // stopping state\n  {\n    float64_t max_strong_acc{get_parameter(\"smooth_stop_max_strong_acc\").as_double()};\n    float64_t min_strong_acc{get_parameter(\"smooth_stop_min_strong_acc\").as_double()};\n    float64_t weak_acc{get_parameter(\"smooth_stop_weak_acc\").as_double()};\n    float64_t weak_stop_acc{get_parameter(\"smooth_stop_weak_stop_acc\").as_double()};\n    float64_t strong_stop_acc{get_parameter(\"smooth_stop_strong_stop_acc\").as_double()};\n    float64_t max_fast_vel{get_parameter(\"smooth_stop_max_fast_vel\").as_double()};\n    float64_t min_running_vel{get_parameter(\"smooth_stop_min_running_vel\").as_double()};\n    float64_t min_running_acc{get_parameter(\"smooth_stop_min_running_acc\").as_double()};\n    float64_t weak_stop_time{get_parameter(\"smooth_stop_weak_stop_time\").as_double()};\n    float64_t weak_stop_dist{get_parameter(\"smooth_stop_weak_stop_dist\").as_double()};\n    float64_t strong_stop_dist{get_parameter(\"smooth_stop_strong_stop_dist\").as_double()};\n    update_param(\"smooth_stop_max_strong_acc\", max_strong_acc);\n    update_param(\"smooth_stop_min_strong_acc\", min_strong_acc);\n    update_param(\"smooth_stop_weak_acc\", weak_acc);\n    update_param(\"smooth_stop_weak_stop_acc\", weak_stop_acc);\n    update_param(\"smooth_stop_strong_stop_acc\", strong_stop_acc);\n    update_param(\"smooth_stop_max_fast_vel\", max_fast_vel);\n    update_param(\"smooth_stop_min_running_vel\", min_running_vel);\n    update_param(\"smooth_stop_min_running_acc\", min_running_acc);\n    update_param(\"smooth_stop_weak_stop_time\", weak_stop_time);\n    update_param(\"smooth_stop_weak_stop_dist\", weak_stop_dist);\n    update_param(\"smooth_stop_strong_stop_dist\", strong_stop_dist);\n    m_smooth_stop.setParams(\n      max_strong_acc, min_strong_acc, weak_acc, weak_stop_acc, strong_stop_acc, max_fast_vel,\n      min_running_vel, min_running_acc, weak_stop_time, weak_stop_dist, strong_stop_dist);\n  }\n\n  // stop state\n  {\n    auto & p = m_stopped_state_params;\n    update_param(\"stopped_vel\", p.vel);\n    update_param(\"stopped_acc\", p.acc);\n    update_param(\"stopped_jerk\", p.jerk);\n  }\n\n  // emergency state\n  {\n    auto & p = m_emergency_state_params;\n    update_param(\"emergency_vel\", p.vel);\n    update_param(\"emergency_acc\", p.acc);\n    update_param(\"emergency_jerk\", p.jerk);\n  }\n\n  // acceleration limit\n  update_param(\"min_acc\", m_min_acc);\n\n  // jerk limit\n  update_param(\"max_jerk\", m_max_jerk);\n  update_param(\"min_jerk\", m_min_jerk);\n\n  // slope compensation\n  update_param(\"max_pitch_rad\", m_max_pitch_rad);\n  update_param(\"min_pitch_rad\", m_min_pitch_rad);\n\n  rcl_interfaces::msg::SetParametersResult result;\n  result.successful = true;\n  result.reason = \"success\";\n  return result;\n}\n\nvoid LongitudinalController::callbackTimerControl()\n{\n  // wait for initial pointers\n  if (\n    !m_current_velocity_ptr || !m_prev_velocity_ptr || !m_trajectory_ptr ||\n    !m_tf_buffer.canTransform(m_trajectory_ptr->header.frame_id, \"base_link\", tf2::TimePointZero)) {\n    return;\n  }\n\n  // get current ego pose\n  geometry_msgs::msg::TransformStamped tf =\n    m_tf_buffer.lookupTransform(m_trajectory_ptr->header.frame_id, \"base_link\", tf2::TimePointZero);\n\n  // calculate current pose and control data\n  geometry_msgs::msg::Pose current_pose;\n  current_pose.position.x = tf.transform.translation.x;\n  current_pose.position.y = tf.transform.translation.y;\n  current_pose.position.z = tf.transform.translation.z;\n  current_pose.orientation = tf.transform.rotation;\n\n  const auto control_data = getControlData(current_pose);\n\n  // self pose is far from trajectory\n  if (control_data.is_far_from_trajectory) {\n    m_control_state = ControlState::EMERGENCY;                          // update control state\n    const Motion raw_ctrl_cmd = calcEmergencyCtrlCmd(control_data.dt);  // calculate control command\n    m_prev_raw_ctrl_cmd = raw_ctrl_cmd;\n    publishCtrlCmd(raw_ctrl_cmd, control_data.current_motion.vel);  // publish control command\n    publishDebugData(raw_ctrl_cmd, control_data);                   // publish debug data\n    return;\n  }\n\n  // update control state\n  m_control_state = updateControlState(m_control_state, control_data);\n\n  // calculate control command\n  const Motion ctrl_cmd = calcCtrlCmd(m_control_state, current_pose, control_data);\n\n  // publish control command\n  publishCtrlCmd(ctrl_cmd, control_data.current_motion.vel);\n\n  // publish error report\n  publishErrors();\n\n  // publish debug data\n  publishDebugData(ctrl_cmd, control_data);\n}\n\nLongitudinalController::ControlData LongitudinalController::getControlData(\n  const geometry_msgs::msg::Pose & current_pose)\n{\n  ControlData control_data{};\n\n  // dt\n  control_data.dt = getDt();\n\n  // current velocity and acceleration\n  control_data.current_motion = getCurrentMotion();\n\n  // nearest idx\n  const float64_t max_dist = m_state_transition_params.emergency_state_traj_trans_dev;\n  const float64_t max_yaw = m_state_transition_params.emergency_state_traj_rot_dev;\n  const auto nearest_idx_opt =\n    motion_common::findNearestIndex(m_trajectory_ptr->points, current_pose, max_dist, max_yaw);\n\n  // return here if nearest index is not found\n  if (!nearest_idx_opt) {\n    control_data.is_far_from_trajectory = true;\n    return control_data;\n  }\n  control_data.nearest_idx = *nearest_idx_opt;\n\n  // shift\n  control_data.shift = getCurrentShift(control_data.nearest_idx);\n  if (control_data.shift != m_prev_shift) {\n    m_pid_vel.reset();\n  }\n  m_prev_shift = control_data.shift;\n\n  // distance to stopline\n  control_data.stop_dist = trajectory_follower::longitudinal_utils::calcStopDistance(\n    current_pose.position, *m_trajectory_ptr);\n\n  // pitch\n  const float64_t raw_pitch =\n    trajectory_follower::longitudinal_utils::getPitchByPose(current_pose.orientation);\n  const float64_t traj_pitch = trajectory_follower::longitudinal_utils::getPitchByTraj(\n    *m_trajectory_ptr, control_data.nearest_idx, m_wheel_base);\n  control_data.slope_angle = m_use_traj_for_pitch ? traj_pitch : m_lpf_pitch->filter(raw_pitch);\n  updatePitchDebugValues(control_data.slope_angle, traj_pitch, raw_pitch);\n\n  return control_data;\n}\n\nLongitudinalController::Motion LongitudinalController::calcEmergencyCtrlCmd(\n  const float64_t dt) const\n{\n  // These accelerations are without slope compensation\n  const auto & p = m_emergency_state_params;\n  const float64_t vel = trajectory_follower::longitudinal_utils::applyDiffLimitFilter(\n    p.vel, m_prev_raw_ctrl_cmd.vel, dt, p.acc);\n  const float64_t acc = trajectory_follower::longitudinal_utils::applyDiffLimitFilter(\n    p.acc, m_prev_raw_ctrl_cmd.acc, dt, p.jerk);\n\n  auto clock = rclcpp::Clock{RCL_ROS_TIME};\n  RCLCPP_ERROR_THROTTLE(\n    get_logger(), clock, 3000, \"[Emergency stop] vel: %3.3f, acc: %3.3f\", vel, acc);\n\n  return Motion{vel, acc};\n}\n\nLongitudinalController::ControlState LongitudinalController::updateControlState(\n  const ControlState current_control_state, const ControlData & control_data)\n{\n  const float64_t current_vel = control_data.current_motion.vel;\n  const float64_t current_acc = control_data.current_motion.acc;\n  const float64_t stop_dist = control_data.stop_dist;\n\n  // flags for state transition\n  const auto & p = m_state_transition_params;\n\n  const bool8_t departure_condition_from_stopping =\n    stop_dist > p.drive_state_stop_dist + p.drive_state_offset_stop_dist;\n  const bool8_t departure_condition_from_stopped = stop_dist > p.drive_state_stop_dist;\n\n  const bool8_t stopping_condition = stop_dist < p.stopping_state_stop_dist;\n  if (\n    std::fabs(current_vel) > p.stopped_state_entry_vel ||\n    std::fabs(current_acc) > p.stopped_state_entry_acc) {\n    m_last_running_time = std::make_shared<rclcpp::Time>(this->now());\n  }\n  const bool8_t stopped_condition =\n    m_last_running_time\n      ? (this->now() - *m_last_running_time).seconds() > p.stopped_state_entry_duration_time\n      : false;\n\n  const bool8_t emergency_condition =\n    m_enable_overshoot_emergency && stop_dist < -p.emergency_state_overshoot_stop_dist;\n\n  // transit state\n  if (current_control_state == ControlState::DRIVE) {\n    if (emergency_condition) {\n      return ControlState::EMERGENCY;\n    }\n\n    if (m_enable_smooth_stop) {\n      if (stopping_condition) {\n        // predictions after input time delay\n        const float64_t pred_vel_in_target =\n          predictedVelocityInTargetPoint(control_data.current_motion, m_delay_compensation_time);\n        const float64_t pred_stop_dist =\n          control_data.stop_dist -\n          0.5 * (pred_vel_in_target + current_vel) * m_delay_compensation_time;\n        m_smooth_stop.init(pred_vel_in_target, pred_stop_dist);\n        return ControlState::STOPPING;\n      }\n    } else {\n      if (stopped_condition && !departure_condition_from_stopped) {\n        return ControlState::STOPPED;\n      }\n    }\n  } else if (current_control_state == ControlState::STOPPING) {\n    if (emergency_condition) {\n      return ControlState::EMERGENCY;\n    }\n\n    if (stopped_condition) {\n      return ControlState::STOPPED;\n    }\n\n    if (departure_condition_from_stopping) {\n      m_pid_vel.reset();\n      m_lpf_vel_error->reset(0.0);\n      // prevent the car from taking a long time to start to move\n      m_prev_ctrl_cmd.acc = std::max(0.0, m_prev_ctrl_cmd.acc);\n      return ControlState::DRIVE;\n    }\n  } else if (current_control_state == ControlState::STOPPED) {\n    if (departure_condition_from_stopped) {\n      m_pid_vel.reset();\n      m_lpf_vel_error->reset(0.0);\n      // prevent the car from taking a long time to start to move\n      m_prev_ctrl_cmd.acc = std::max(0.0, m_prev_ctrl_cmd.acc);\n      return ControlState::DRIVE;\n    }\n  } else if (m_control_state == ControlState::EMERGENCY) {\n    if (stopped_condition && !emergency_condition) {\n      return ControlState::STOPPED;\n    }\n  }\n\n  return current_control_state;\n}\n\nLongitudinalController::Motion LongitudinalController::calcCtrlCmd(\n  const ControlState & current_control_state, const geometry_msgs::msg::Pose & current_pose,\n  const ControlData & control_data)\n{\n  const size_t nearest_idx = control_data.nearest_idx;\n  const float64_t current_vel = control_data.current_motion.vel;\n  const float64_t current_acc = control_data.current_motion.acc;\n\n  // velocity and acceleration command\n  Motion raw_ctrl_cmd{};\n  Motion target_motion{};\n  if (current_control_state == ControlState::DRIVE) {\n    const auto target_pose = trajectory_follower::longitudinal_utils::calcPoseAfterTimeDelay(\n      current_pose, m_delay_compensation_time, current_vel);\n    const auto target_interpolated_point =\n      calcInterpolatedTargetValue(*m_trajectory_ptr, target_pose.position, nearest_idx);\n    target_motion = Motion{\n      target_interpolated_point.longitudinal_velocity_mps,\n      target_interpolated_point.acceleration_mps2};\n\n    target_motion = keepBrakeBeforeStop(*m_trajectory_ptr, target_motion, nearest_idx);\n\n    const float64_t pred_vel_in_target =\n      predictedVelocityInTargetPoint(control_data.current_motion, m_delay_compensation_time);\n    m_debug_values.setValues(\n      trajectory_follower::DebugValues::TYPE::PREDICTED_VEL, pred_vel_in_target);\n\n    raw_ctrl_cmd.vel = target_motion.vel;\n    raw_ctrl_cmd.acc = applyVelocityFeedback(target_motion, control_data.dt, pred_vel_in_target);\n    RCLCPP_DEBUG(\n      get_logger(),\n      \"[feedback control]  vel: %3.3f, acc: %3.3f, dt: %3.3f, v_curr: %3.3f, v_ref: %3.3f \"\n      \"feedback_ctrl_cmd.ac: %3.3f\",\n      raw_ctrl_cmd.vel, raw_ctrl_cmd.acc, control_data.dt, current_vel, target_motion.vel,\n      raw_ctrl_cmd.acc);\n  } else if (current_control_state == ControlState::STOPPING) {\n    raw_ctrl_cmd.acc = m_smooth_stop.calculate(\n      control_data.stop_dist, current_vel, current_acc, m_vel_hist, m_delay_compensation_time);\n    raw_ctrl_cmd.vel = m_stopped_state_params.vel;\n\n    RCLCPP_DEBUG(\n      get_logger(), \"[smooth stop]: Smooth stopping. vel: %3.3f, acc: %3.3f\", raw_ctrl_cmd.vel,\n      raw_ctrl_cmd.acc);\n  } else if (current_control_state == ControlState::STOPPED) {\n    // This acceleration is without slope compensation\n    const auto & p = m_stopped_state_params;\n    raw_ctrl_cmd.vel = p.vel;\n    raw_ctrl_cmd.acc = trajectory_follower::longitudinal_utils::applyDiffLimitFilter(\n      p.acc, m_prev_raw_ctrl_cmd.acc, control_data.dt, p.jerk);\n\n    RCLCPP_DEBUG(\n      get_logger(), \"[Stopped]. vel: %3.3f, acc: %3.3f\", raw_ctrl_cmd.vel, raw_ctrl_cmd.acc);\n  } else if (current_control_state == ControlState::EMERGENCY) {\n    raw_ctrl_cmd = calcEmergencyCtrlCmd(control_data.dt);\n  }\n\n  // store acceleration without slope compensation\n  m_prev_raw_ctrl_cmd = raw_ctrl_cmd;\n\n  // apply slope compensation and filter acceleration and jerk\n  const float64_t filtered_acc_cmd = calcFilteredAcc(raw_ctrl_cmd.acc, control_data);\n  const Motion filtered_ctrl_cmd{raw_ctrl_cmd.vel, filtered_acc_cmd};\n\n  // update debug visualization\n  updateDebugVelAcc(target_motion, current_pose, control_data);\n\n  // Calculate controller error report msg.\n  calcErrorReports(control_data, target_motion);\n\n  return filtered_ctrl_cmd;\n}\n\n// Do not use nearest_idx here\nvoid LongitudinalController::publishCtrlCmd(const Motion & ctrl_cmd, float64_t current_vel)\n{\n  // publish control command\n  autoware_auto_control_msgs::msg::LongitudinalCommand cmd{};\n  cmd.stamp = this->now();\n  cmd.speed = static_cast<decltype(cmd.speed)>(ctrl_cmd.vel);\n  cmd.acceleration = static_cast<decltype(cmd.acceleration)>(ctrl_cmd.acc);\n  m_pub_control_cmd->publish(cmd);\n\n  // store current velocity history\n  m_vel_hist.push_back({this->now(), current_vel});\n  while (m_vel_hist.size() > static_cast<size_t>(0.5 / m_longitudinal_ctrl_period)) {\n    m_vel_hist.erase(m_vel_hist.begin());\n  }\n\n  m_prev_ctrl_cmd = ctrl_cmd;\n}\n\nvoid LongitudinalController::LongitudinalController::publishErrors()\n{\n  ControllerErrorReport error_report{};\n  error_report.velocity_error_read = m_current_velocity_error_to_report;\n  error_report.acceleration_error_read = m_current_acc_error_to_report;\n\n  error_report.stamp = this->now();\n  m_pub_ctrl_error_report->publish(error_report);\n}\n\nvoid LongitudinalController::publishDebugData(\n  const Motion & ctrl_cmd, const ControlData & control_data)\n{\n  using trajectory_follower::DebugValues;\n  // set debug values\n  m_debug_values.setValues(DebugValues::TYPE::DT, control_data.dt);\n  m_debug_values.setValues(DebugValues::TYPE::CALCULATED_ACC, control_data.current_motion.acc);\n  m_debug_values.setValues(DebugValues::TYPE::SHIFT, static_cast<float64_t>(control_data.shift));\n  m_debug_values.setValues(DebugValues::TYPE::STOP_DIST, control_data.stop_dist);\n  m_debug_values.setValues(\n    DebugValues::TYPE::CONTROL_STATE, static_cast<float64_t>(m_control_state));\n  m_debug_values.setValues(DebugValues::TYPE::ACC_CMD_PUBLISHED, ctrl_cmd.acc);\n\n  // publish debug values\n  autoware_auto_system_msgs::msg::Float32MultiArrayDiagnostic debug_msg{};\n  debug_msg.diag_header.data_stamp = this->now();\n  for (const auto & v : m_debug_values.getValues()) {\n    debug_msg.diag_array.data.push_back(\n      static_cast<decltype(debug_msg.diag_array.data)::value_type>(v));\n  }\n  m_pub_debug->publish(debug_msg);\n\n  // slope angle\n  autoware_auto_system_msgs::msg::Float32MultiArrayDiagnostic slope_msg{};\n  slope_msg.diag_header.data_stamp = this->now();\n  slope_msg.diag_array.data.push_back(\n    static_cast<decltype(slope_msg.diag_array.data)::value_type>(control_data.slope_angle));\n  m_pub_slope->publish(slope_msg);\n}\n\nfloat64_t LongitudinalController::getDt()\n{\n  float64_t dt;\n  if (!m_prev_control_time) {\n    dt = m_longitudinal_ctrl_period;\n    m_prev_control_time = std::make_shared<rclcpp::Time>(this->now());\n  } else {\n    dt = (this->now() - *m_prev_control_time).seconds();\n    *m_prev_control_time = this->now();\n  }\n  const float64_t max_dt = m_longitudinal_ctrl_period * 2.0;\n  const float64_t min_dt = m_longitudinal_ctrl_period * 0.5;\n  return std::max(std::min(dt, max_dt), min_dt);\n}\n\nLongitudinalController::Motion LongitudinalController::getCurrentMotion() const\n{\n  const float64_t dv =\n    m_current_velocity_ptr->twist.twist.linear.x - m_prev_velocity_ptr->twist.twist.linear.x;\n  const float64_t dt = std::max(\n    (rclcpp::Time(m_current_velocity_ptr->header.stamp) -\n     rclcpp::Time(m_prev_velocity_ptr->header.stamp))\n      .seconds(),\n    1e-03);\n  const float64_t accel = dv / dt;\n\n  const float64_t current_vel = m_current_velocity_ptr->twist.twist.linear.x;\n  const float64_t current_acc = m_lpf_acc->filter(accel);\n\n  return Motion{current_vel, current_acc};\n}\n\nenum LongitudinalController::Shift LongitudinalController::getCurrentShift(\n  const size_t nearest_idx) const\n{\n  constexpr float64_t epsilon = 1e-5;\n\n  const float64_t target_vel = m_trajectory_ptr->points.at(nearest_idx).longitudinal_velocity_mps;\n\n  if (target_vel > epsilon) {\n    return Shift::Forward;\n  } else if (target_vel < -epsilon) {\n    return Shift::Reverse;\n  }\n\n  return m_prev_shift;\n}\n\nfloat64_t LongitudinalController::calcFilteredAcc(\n  const float64_t raw_acc, const ControlData & control_data)\n{\n  using trajectory_follower::DebugValues;\n  const float64_t acc_max_filtered = ::motion::motion_common::clamp(raw_acc, m_min_acc, m_max_acc);\n  m_debug_values.setValues(DebugValues::TYPE::ACC_CMD_ACC_LIMITED, acc_max_filtered);\n\n  // store ctrl cmd without slope filter\n  storeAccelCmd(acc_max_filtered);\n\n  const float64_t acc_slope_filtered =\n    applySlopeCompensation(acc_max_filtered, control_data.slope_angle, control_data.shift);\n  m_debug_values.setValues(DebugValues::TYPE::ACC_CMD_SLOPE_APPLIED, acc_slope_filtered);\n\n  // This jerk filter must be applied after slope compensation\n  const float64_t acc_jerk_filtered = trajectory_follower::longitudinal_utils::applyDiffLimitFilter(\n    acc_slope_filtered, m_prev_ctrl_cmd.acc, control_data.dt, m_max_jerk, m_min_jerk);\n  m_debug_values.setValues(DebugValues::TYPE::ACC_CMD_JERK_LIMITED, acc_jerk_filtered);\n\n  return acc_jerk_filtered;\n}\n\nvoid LongitudinalController::storeAccelCmd(const float64_t accel)\n{\n  if (m_control_state == ControlState::DRIVE) {\n    // convert format\n    autoware_auto_control_msgs::msg::LongitudinalCommand cmd;\n    cmd.stamp = this->now();\n    cmd.acceleration = static_cast<decltype(cmd.acceleration)>(accel);\n\n    // store published ctrl cmd\n    m_ctrl_cmd_vec.emplace_back(cmd);\n  } else {\n    // reset command\n    m_ctrl_cmd_vec.clear();\n  }\n\n  // remove unused ctrl cmd\n  if (m_ctrl_cmd_vec.size() <= 2) {\n    return;\n  }\n  if ((this->now() - m_ctrl_cmd_vec.at(1).stamp).seconds() > m_delay_compensation_time) {\n    m_ctrl_cmd_vec.erase(m_ctrl_cmd_vec.begin());\n  }\n}\n\nfloat64_t LongitudinalController::applySlopeCompensation(\n  const float64_t input_acc, const float64_t pitch, const Shift shift) const\n{\n  if (!m_enable_slope_compensation) {\n    return input_acc;\n  }\n  const float64_t pitch_limited = std::min(std::max(pitch, m_min_pitch_rad), m_max_pitch_rad);\n\n  // Acceleration command is always positive independent of direction (= shift) when car is running\n  float64_t sign = (shift == Shift::Forward) ? -1 : (shift == Shift::Reverse ? 1 : 0);\n  float64_t compensated_acc = input_acc + sign * 9.81 * std::sin(pitch_limited);\n  return compensated_acc;\n}\n\nLongitudinalController::Motion LongitudinalController::keepBrakeBeforeStop(\n  const autoware_auto_planning_msgs::msg::Trajectory & traj, const Motion & target_motion,\n  const size_t nearest_idx) const\n{\n  Motion output_motion = target_motion;\n\n  if (m_enable_brake_keeping_before_stop == false) {\n    return output_motion;\n  }\n  // const auto stop_idx = tier4_autoware_utils::searchZeroVelocityIndex(traj.points);\n  const auto stop_idx = motion_common::searchZeroVelocityIndex(traj.points);\n  if (!stop_idx) {\n    return output_motion;\n  }\n\n  float64_t min_acc_before_stop = std::numeric_limits<float64_t>::max();\n  size_t min_acc_idx = std::numeric_limits<size_t>::max();\n  for (int i = static_cast<int>(*stop_idx); i >= 0; --i) {\n    const auto ui = static_cast<size_t>(i);\n    if (traj.points.at(ui).acceleration_mps2 > static_cast<float>(min_acc_before_stop)) {\n      break;\n    }\n    min_acc_before_stop = traj.points.at(ui).acceleration_mps2;\n    min_acc_idx = ui;\n  }\n\n  const float64_t brake_keeping_acc = std::max(m_brake_keeping_acc, min_acc_before_stop);\n  if (nearest_idx >= min_acc_idx && target_motion.acc > brake_keeping_acc) {\n    output_motion.acc = brake_keeping_acc;\n  }\n\n  return output_motion;\n}\n\nautoware_auto_planning_msgs::msg::TrajectoryPoint\nLongitudinalController::calcInterpolatedTargetValue(\n  const autoware_auto_planning_msgs::msg::Trajectory & traj,\n  const geometry_msgs::msg::Point & point, const size_t nearest_idx) const\n{\n  if (traj.points.size() == 1) {\n    return traj.points.at(0);\n  }\n\n  // If the current position is not within the reference trajectory, enable the edge value.\n  // Else, apply linear interpolation\n  if (nearest_idx == 0) {\n    if (motion_common::calcSignedArcLength(traj.points, point, 0) > 0) {\n      return traj.points.at(0);\n    }\n  }\n  if (nearest_idx == traj.points.size() - 1) {\n    if (motion_common::calcSignedArcLength(traj.points, point, traj.points.size() - 1) < 0) {\n      return traj.points.at(traj.points.size() - 1);\n    }\n  }\n\n  // apply linear interpolation\n  return trajectory_follower::longitudinal_utils::lerpTrajectoryPoint(traj.points, point);\n}\n\nfloat64_t LongitudinalController::predictedVelocityInTargetPoint(\n  const Motion current_motion, const float64_t delay_compensation_time) const\n{\n  const float64_t current_vel = current_motion.vel;\n  const float64_t current_acc = current_motion.acc;\n\n  if (std::fabs(current_vel) < 1e-01) {  // when velocity is low, no prediction\n    return current_vel;\n  }\n\n  const float64_t current_vel_abs = std::fabs(current_vel);\n  if (m_ctrl_cmd_vec.size() == 0) {\n    const float64_t pred_vel = current_vel + current_acc * delay_compensation_time;\n    // avoid to change sign of current_vel and pred_vel\n    return pred_vel > 0 ? std::copysign(pred_vel, current_vel) : 0.0;\n  }\n\n  float64_t pred_vel = current_vel_abs;\n\n  const auto past_delay_time =\n    this->now() - rclcpp::Duration::from_seconds(delay_compensation_time);\n  for (std::size_t i = 0; i < m_ctrl_cmd_vec.size(); ++i) {\n    if ((this->now() - m_ctrl_cmd_vec.at(i).stamp).seconds() < m_delay_compensation_time) {\n      if (i == 0) {\n        // size of m_ctrl_cmd_vec is less than m_delay_compensation_time\n        pred_vel = current_vel_abs + static_cast<float64_t>(m_ctrl_cmd_vec.at(i).acceleration) *\n                                       delay_compensation_time;\n        return pred_vel > 0 ? std::copysign(pred_vel, current_vel) : 0.0;\n      }\n      // add velocity to accel * dt\n      const float64_t acc = m_ctrl_cmd_vec.at(i - 1).acceleration;\n      const auto curr_time_i = rclcpp::Time(m_ctrl_cmd_vec.at(i).stamp);\n      const float64_t time_to_next_acc = std::min(\n        (curr_time_i - rclcpp::Time(m_ctrl_cmd_vec.at(i - 1).stamp)).seconds(),\n        (curr_time_i - past_delay_time).seconds());\n      pred_vel += acc * time_to_next_acc;\n    }\n  }\n\n  const float64_t last_acc = m_ctrl_cmd_vec.at(m_ctrl_cmd_vec.size() - 1).acceleration;\n  const float64_t time_to_current =\n    (this->now() - m_ctrl_cmd_vec.at(m_ctrl_cmd_vec.size() - 1).stamp).seconds();\n  pred_vel += last_acc * time_to_current;\n\n  // avoid to change sign of current_vel and pred_vel\n  return pred_vel > 0 ? std::copysign(pred_vel, current_vel) : 0.0;\n}\n\nfloat64_t LongitudinalController::applyVelocityFeedback(\n  const Motion target_motion, const float64_t dt, const float64_t current_vel)\n{\n  using trajectory_follower::DebugValues;\n  const float64_t current_vel_abs = std::fabs(current_vel);\n  const float64_t target_vel_abs = std::fabs(target_motion.vel);\n\n  const bool8_t enable_integration = (current_vel_abs > m_current_vel_threshold_pid_integrate);\n  const float64_t error_vel_filtered = m_lpf_vel_error->filter(target_vel_abs - current_vel_abs);\n\n  std::vector<float64_t> pid_contributions(3);\n\n  const float64_t pid_acc =\n    m_pid_vel.calculate(error_vel_filtered, dt, enable_integration, pid_contributions);\n\n  const float64_t feedback_acc = target_motion.acc + pid_acc;\n\n  m_debug_values.setValues(DebugValues::TYPE::ACC_CMD_PID_APPLIED, feedback_acc);\n  m_debug_values.setValues(DebugValues::TYPE::ERROR_VEL_FILTERED, error_vel_filtered);\n  m_debug_values.setValues(\n    DebugValues::TYPE::ACC_CMD_FB_P_CONTRIBUTION, pid_contributions.at(0));  // P\n  m_debug_values.setValues(\n    DebugValues::TYPE::ACC_CMD_FB_I_CONTRIBUTION, pid_contributions.at(1));  // I\n  m_debug_values.setValues(\n    DebugValues::TYPE::ACC_CMD_FB_D_CONTRIBUTION, pid_contributions.at(2));  // D\n\n  return feedback_acc;\n}\n\nvoid LongitudinalController::updatePitchDebugValues(\n  const float64_t pitch, const float64_t traj_pitch, const float64_t raw_pitch)\n{\n  using trajectory_follower::DebugValues;\n  const float64_t to_degrees = (180.0 / static_cast<float64_t>(autoware::common::types::PI));\n  m_debug_values.setValues(DebugValues::TYPE::PITCH_LPF_RAD, pitch);\n  m_debug_values.setValues(DebugValues::TYPE::PITCH_LPF_DEG, pitch * to_degrees);\n  m_debug_values.setValues(DebugValues::TYPE::PITCH_RAW_RAD, raw_pitch);\n  m_debug_values.setValues(DebugValues::TYPE::PITCH_RAW_DEG, raw_pitch * to_degrees);\n  m_debug_values.setValues(DebugValues::TYPE::PITCH_RAW_TRAJ_RAD, traj_pitch);\n  m_debug_values.setValues(DebugValues::TYPE::PITCH_RAW_TRAJ_DEG, traj_pitch * to_degrees);\n}\n\nvoid LongitudinalController::updateDebugVelAcc(\n  const Motion & target_motion, const geometry_msgs::msg::Pose & current_pose,\n  const ControlData & control_data)\n{\n  using trajectory_follower::DebugValues;\n  const float64_t current_vel = control_data.current_motion.vel;\n  const size_t nearest_idx = control_data.nearest_idx;\n\n  const auto interpolated_point =\n    calcInterpolatedTargetValue(*m_trajectory_ptr, current_pose.position, nearest_idx);\n\n  m_debug_values.setValues(DebugValues::TYPE::CURRENT_VEL, current_vel);\n  m_debug_values.setValues(DebugValues::TYPE::TARGET_VEL, target_motion.vel);\n  m_debug_values.setValues(DebugValues::TYPE::TARGET_ACC, target_motion.acc);\n  m_debug_values.setValues(\n    DebugValues::TYPE::NEAREST_VEL, interpolated_point.longitudinal_velocity_mps);\n  m_debug_values.setValues(DebugValues::TYPE::NEAREST_ACC, interpolated_point.acceleration_mps2);\n  m_debug_values.setValues(DebugValues::TYPE::ERROR_VEL, target_motion.vel - current_vel);\n}\n\nvoid LongitudinalController::calcErrorReports(\n  ControlData const & current_data, Motion const & target_motion)\n{\n  // acceleration velocity error to report : target - current\n  m_current_velocity_error_to_report = target_motion.vel - current_data.current_motion.vel;\n  m_current_acc_error_to_report = target_motion.acc - current_data.current_motion.acc;\n}\n\n}  // namespace trajectory_follower_nodes\n}  // namespace control\n}  // namespace motion\n}  // namespace autoware\n\n#include \"rclcpp_components/register_node_macro.hpp\"\nRCLCPP_COMPONENTS_REGISTER_NODE(\n  autoware::motion::control::trajectory_follower_nodes::LongitudinalController)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/longitudinal_controller_node.cpp b/src/longitudinal_controller_node.cpp
--- a/src/longitudinal_controller_node.cpp	(revision c5c7724510fa7da49e3cf2fb9ba8357f407a21fe)
+++ b/src/longitudinal_controller_node.cpp	(date 1656122290840)
@@ -656,6 +656,7 @@
   ControllerErrorReport error_report{};
   error_report.velocity_error_read = m_current_velocity_error_to_report;
   error_report.acceleration_error_read = m_current_acc_error_to_report;
+  error_report.target_velocity_read = m_target_velocity_to_report;
 
   error_report.stamp = this->now();
   m_pub_ctrl_error_report->publish(error_report);
