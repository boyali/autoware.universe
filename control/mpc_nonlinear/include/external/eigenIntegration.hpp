/* 
* Boost Software License - Version 1.0 - August 17th, 2003
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:

* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/
/*
* Copyright 2021 - 2022 Autoware Foundation. All rights reserved.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

#ifndef EXTERNAL__EIGENINTEGRATION_HPP_
#define EXTERNAL__EIGENINTEGRATION_HPP_

#include <Eigen/Dense>
#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>
#include <boost/version.hpp>

/** 
 * @brief Necessary routines for Eigen matrices to make them work with vector_space_algebra. 
*/

#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)
namespace Eigen
{
namespace internal
{
template <typename Scalar>
struct scalar_add_op
{
  EIGEN_DEVICE_FUNC inline scalar_add_op(const scalar_add_op & other) : m_other(other.m_other) {}
  EIGEN_DEVICE_FUNC inline scalar_add_op(const Scalar & other) : m_other(other) {}
  EIGEN_DEVICE_FUNC inline Scalar operator()(const Scalar & a) const { return a + m_other; }
  template <typename Packet>
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet & a) const
  {
    return internal::padd(a, pset1<Packet>(m_other));
  }
  const Scalar m_other;
};

template <typename Scalar>
struct functor_traits<scalar_add_op<Scalar>>
{
  enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasAdd };
};

}  // namespace internal

template <typename D>
inline const typename Eigen::CwiseUnaryOp<
  typename Eigen::internal::scalar_add_op<typename Eigen::internal::traits<D>::Scalar>, const D>
operator+(
  const typename Eigen::MatrixBase<D> & m, const typename Eigen::internal::traits<D>::Scalar & s)
{
  return Eigen::CwiseUnaryOp<
    typename Eigen::internal::scalar_add_op<typename Eigen::internal::traits<D>::Scalar>, const D>(
    m.derived(), Eigen::internal::scalar_add_op<typename Eigen::internal::traits<D>::Scalar>(s));
}

template <typename D>
inline const typename Eigen::CwiseUnaryOp<
  typename Eigen::internal::scalar_add_op<typename Eigen::internal::traits<D>::Scalar>, const D>
operator+(
  const typename Eigen::internal::traits<D>::Scalar & s, const typename Eigen::MatrixBase<D> & m)
{
  return Eigen::CwiseUnaryOp<
    typename Eigen::internal::scalar_add_op<typename Eigen::internal::traits<D>::Scalar>, const D>(
    m.derived(), Eigen::internal::scalar_add_op<typename Eigen::internal::traits<D>::Scalar>(s));
}

template <typename D1, typename D2>
inline const typename Eigen::CwiseBinaryOp<
  typename Eigen::internal::scalar_quotient_op<typename Eigen::internal::traits<D1>::Scalar>,
  const D1, const D2>
operator/(const Eigen::MatrixBase<D1> & x1, const Eigen::MatrixBase<D2> & x2)
{
  return x1.cwiseQuotient(x2);
}

template <typename D>
inline const typename Eigen::CwiseUnaryOp<
  typename Eigen::internal::scalar_abs_op<typename Eigen::internal::traits<D>::Scalar>, const D>
abs(const Eigen::MatrixBase<D> & m)
{
  return m.cwiseAbs();
}

}  // namespace Eigen

namespace boost
{
namespace numeric
{
namespace odeint
{
template <int S1, int S2, int O, int M1, int M2>
struct vector_space_norm_inf<Eigen::Matrix<double, S1, S2, O, M1, M2>>
{
  EIGEN_MAKE_ALIGNED_OPERATOR_NEW

  typedef double result_type;
  result_type operator()(const Eigen::Matrix<double, S1, S2, O, M1, M2> & m) const
  {
    return m.template lpNorm<Eigen::Infinity>();
  }
};

}  // namespace odeint
}  // namespace numeric
}  // namespace boost

#endif
#endif  // EXTERNAL__EIGENINTEGRATION_HPP_
